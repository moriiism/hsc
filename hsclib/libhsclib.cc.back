#include "libhsclib.h"

void HscData::Init(int nftr)
{
    nftr_    = nftr;
    ftr_arr_ = new double [nftr];
    for(int iftr = 0; iftr < nftr; iftr ++){
        ftr_arr_[iftr] = 0.0;
    }
    true_false_ = 0;
}

void HscData::Set16051900(double mag,
                          double magerr,
                          double elongation_norm,
                          double fwhm_norm,
                          double significance_abs,
                          double residual,
                          double psffit_sigma_ratio,
                          double psffit_peak_ratio,
                          double frac_det,
                          double density,
                          double density_good,
                          double bapsf,
                          double psf)
{
    int iftr = 0;
    ftr_arr_[iftr] = mag;                iftr ++;
    ftr_arr_[iftr] = magerr;             iftr ++;
    ftr_arr_[iftr] = elongation_norm;    iftr ++;
    ftr_arr_[iftr] = fwhm_norm;          iftr ++;
    ftr_arr_[iftr] = significance_abs;   iftr ++;
    ftr_arr_[iftr] = residual;           iftr ++;
    ftr_arr_[iftr] = psffit_sigma_ratio; iftr ++;
    ftr_arr_[iftr] = psffit_peak_ratio;  iftr ++;
    ftr_arr_[iftr] = frac_det;           iftr ++;
    ftr_arr_[iftr] = density;            iftr ++;
    ftr_arr_[iftr] = density_good;       iftr ++;
    ftr_arr_[iftr] = bapsf;              iftr ++;
    ftr_arr_[iftr] = psf;                iftr ++;
}

void HscData::Set17112400(double magerr,
                          double elongation_norm,
                          double fwhm_norm,
                          double significance_abs,
                          double residual,
                          double psffit_sigma_ratio,
                          double psffit_peak_ratio,
                          double frac_det,
                          double density,
                          double density_good,
                          double bapsf,
                          double sigmapsf)
{
    int iftr = 0;
    ftr_arr_[iftr] = magerr;             iftr ++;
    ftr_arr_[iftr] = elongation_norm;    iftr ++;
    ftr_arr_[iftr] = fwhm_norm;          iftr ++;
    ftr_arr_[iftr] = significance_abs;   iftr ++;
    ftr_arr_[iftr] = residual;           iftr ++;
    ftr_arr_[iftr] = psffit_sigma_ratio; iftr ++;
    ftr_arr_[iftr] = psffit_peak_ratio;  iftr ++;
    ftr_arr_[iftr] = frac_det;           iftr ++;
    ftr_arr_[iftr] = density;            iftr ++;
    ftr_arr_[iftr] = density_good;       iftr ++;
    ftr_arr_[iftr] = bapsf;              iftr ++;
    ftr_arr_[iftr] = sigmapsf;           iftr ++;
}

void HscData::Copy(const HscData* const org)
{
    if(this == org) {abort();}
    if(NULL == org) {abort();}

    Null();

    nftr_    = org->nftr_;
    ftr_arr_ = new double [org->nftr_];
    for(int iftr = 0; iftr < nftr_; iftr ++){
        ftr_arr_[iftr] = org->ftr_arr_[iftr];
    }
    true_false_ = org->true_false_;
}

HscData* const HscData::Clone() const
{
    HscData* obj_new = new HscData;
    obj_new->Copy(this);
    return obj_new;
}

void HscData::Print16051900(FILE* fp) const
{
    int iftr = 0;
    fprintf(fp, "mag                  = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "magerr               = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "elongation_norm      = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "fwhm_norm            = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "significance_abs     = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "residual             = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "psffit_sigma_ratio   = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "psffit_peak_ration   = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "frac_det             = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "density              = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "density_good         = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "bapsf                = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "psf                  = %e\n", ftr_arr_[iftr]); iftr ++;

    fprintf(fp, "nftr_                = %d\n", nftr_);
    fprintf(fp, "true_false_          = %d\n", true_false_);
}

void HscData::Print17112400(FILE* fp) const
{
    int iftr = 0;
    fprintf(fp, "magerr               = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "elongation_norm      = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "fwhm_norm            = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "significance_abs     = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "residual             = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "psffit_sigma_ratio   = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "psffit_peak_ration   = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "frac_det             = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "density              = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "density_good         = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "bapsf                = %e\n", ftr_arr_[iftr]); iftr ++;
    fprintf(fp, "sigmapsf             = %e\n", ftr_arr_[iftr]); iftr ++;

    fprintf(fp, "nftr_                = %d\n", nftr_);
    fprintf(fp, "true_false_          = %d\n", true_false_);
}

// private

void HscData::Null()
{
    if(NULL != ftr_arr_){
        delete [] ftr_arr_;
    }
    nftr_        = 0;
    true_false_  = 0;
}



void LoadCsvDat16051900(string csv_dat,
                        long* const ndata_ptr,
                        HscData*** const hsc_data_arr_ptr,
                        int* const nname_ptr,
                        string** const name_arr_ptr)
{
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(csv_dat, &lines_arr, &nline);
    int nsplit0 = 0;
    string* split0_arr = NULL;
    MiStr::GenSplit(lines_arr[0], &nsplit0, &split0_arr, ",");
    int nname = 13;
    string* name_arr = new string [nname];
    name_arr[0] = split0_arr[2];
    name_arr[1] = split0_arr[3];
    name_arr[2] = split0_arr[4];
    name_arr[3] = split0_arr[5];
    name_arr[4] = split0_arr[6];
    name_arr[5] = split0_arr[7];
    name_arr[6] = split0_arr[8];
    name_arr[7] = split0_arr[9];
    name_arr[8] = split0_arr[10];
    name_arr[9] = split0_arr[11];
    name_arr[10] = split0_arr[12];
    name_arr[11] = split0_arr[13];
    name_arr[12] = split0_arr[14];
    
    long ndata = nline - 1;
    HscData** hsc_data_arr = new HscData* [ndata];
    for(long idata = 0; idata < ndata; idata ++){
        int nsplit = 0;
        string* split_arr = NULL;
        long iline = idata + 1;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr, ",");

        hsc_data_arr[idata] = new HscData;
        hsc_data_arr[idata]->Init(13);
        hsc_data_arr[idata]->Set16051900(atof(split_arr[2].c_str()),
                                         atof(split_arr[3].c_str()),
                                         atof(split_arr[4].c_str()),
                                         atof(split_arr[5].c_str()),
                                         atof(split_arr[6].c_str()),
                                         atof(split_arr[7].c_str()),
                                         atof(split_arr[8].c_str()),
                                         atof(split_arr[9].c_str()),
                                         atof(split_arr[10].c_str()),
                                         atof(split_arr[11].c_str()),
                                         atof(split_arr[12].c_str()),
                                         atof(split_arr[13].c_str()),
                                         atof(split_arr[14].c_str()));
        hsc_data_arr[idata]->SetTrueFalse(atoi(split_arr[15].c_str()));
        MiStr::DelSplit(split_arr);
    }
    delete [] lines_arr;
    *ndata_ptr = ndata;    
    *hsc_data_arr_ptr = hsc_data_arr;
    *nname_ptr = nname;
    *name_arr_ptr = name_arr;
}

void LoadCsvDat17112400(string csv_dat,
                        long* const ndata_ptr,
                        HscData*** const hsc_data_arr_ptr,
                        int* const nname_ptr,
                        string** const name_arr_ptr)
{
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(csv_dat, &lines_arr, &nline);
    int nsplit0 = 0;
    string* split0_arr = NULL;
    MiStr::GenSplit(lines_arr[0], &nsplit0, &split0_arr, ",");
    int nname = 12;
    string* name_arr = new string [nname];
    name_arr[0] = split0_arr[3];
    name_arr[1] = split0_arr[4];
    name_arr[2] = split0_arr[5];
    name_arr[3] = split0_arr[6];
    name_arr[4] = split0_arr[7];
    name_arr[5] = split0_arr[8];
    name_arr[6] = split0_arr[9];
    name_arr[7] = split0_arr[10];
    name_arr[8] = split0_arr[11];
    name_arr[9] = split0_arr[12];
    name_arr[10] = split0_arr[13];
    name_arr[11] = split0_arr[14];
    
    long ndata = nline - 1;
    HscData** hsc_data_arr = new HscData* [ndata];
    for(long idata = 0; idata < ndata; idata ++){
        int nsplit = 0;
        string* split_arr = NULL;
        long iline = idata + 1;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr, ",");

        hsc_data_arr[idata] = new HscData;
        hsc_data_arr[idata]->Init(12);
        hsc_data_arr[idata]->Set17112400(atof(split_arr[3].c_str()),
                                         atof(split_arr[4].c_str()),
                                         atof(split_arr[5].c_str()),
                                         atof(split_arr[6].c_str()),
                                         atof(split_arr[7].c_str()),
                                         atof(split_arr[8].c_str()),
                                         atof(split_arr[9].c_str()),
                                         atof(split_arr[10].c_str()),
                                         atof(split_arr[11].c_str()),
                                         atof(split_arr[12].c_str()),
                                         atof(split_arr[13].c_str()),
                                         atof(split_arr[14].c_str()));
        hsc_data_arr[idata]->SetTrueFalse(atoi(split_arr[15].c_str()));
        MiStr::DelSplit(split_arr);
    }
    delete [] lines_arr;
    *ndata_ptr = ndata;    
    *hsc_data_arr_ptr = hsc_data_arr;
    *nname_ptr = nname;
    *name_arr_ptr = name_arr;
}


void OpenLogfile(string outdir,
                 string outfile_head,
                 string progname,
                 FILE** const fp_log_ptr)
{
    char logfile[kLineSize];
    if( MiIolib::TestFileExist(outdir) ){
        char cmd[kLineSize];
        sprintf(cmd, "mkdir -p %s", outdir.c_str());
        system(cmd);
    }
    sprintf(logfile, "%s/%s_%s.log",
            outdir.c_str(),
            outfile_head.c_str(),
            progname.c_str());
    FILE* fp_log = fopen(logfile, "w");
    MiIolib::Printf2(fp_log, "-----------------------------\n");
    *fp_log_ptr = fp_log;
}


void LoadLambdaDat(string lambda_dat,
                   int* const nlambda_ptr,
                   double** const lambda_arr_ptr)
{
    // read lambda data
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(lambda_dat,
                                    &lines_arr, &nline);
    if(1 != nline){
        abort();
    }
    printf("nline = %ld\n", nline);    
    printf("%s\n", lines_arr[0].c_str());

    int nsplit = 0;
    string* split_arr = NULL;
    MiStr::GenSplit(lines_arr[0], &nsplit, &split_arr);
    long nlambda  = atoi(split_arr[0].c_str());
    double lambda_lo    = atof(split_arr[1].c_str());
    double lambda_up    = atof(split_arr[2].c_str());
    string lambda_scale = split_arr[3];
    MiStr::DelSplit(split_arr);
    double* lambda_arr = new double[nlambda];
    MirBinning::GetPoint(nlambda, lambda_lo, lambda_up, lambda_scale, lambda_arr);

    *nlambda_ptr    = nlambda;
    *lambda_arr_ptr = lambda_arr;
}

void MkTrVlLambdaDat(int nset,
                     int nlambda,
                     const double* const lambda_arr,
                     string outdir)
{
    int nfile_src_id_te   = nset;
    int nfile_src_id_trvl = nset;

    char trvl_lambda_dat[kLineSize];
    sprintf(trvl_lambda_dat, "%s/trvl_lambda.dat", outdir.c_str());
    FILE* fp = fopen(trvl_lambda_dat, "w");
    
    for(int index_te = 1; index_te <= nfile_src_id_te; index_te ++){
        for(int index_trvl = 1; index_trvl <= nfile_src_id_trvl; index_trvl ++){
            char file_src_id_tr[kLineSize];
            char file_src_id_vl[kLineSize];
            sprintf(file_src_id_tr, "cv%2.2d-%2.2d-tr.csv",
                    index_te, index_trvl);
            sprintf(file_src_id_vl, "cv%2.2d-%2.2d-vl.csv",
                    index_te, index_trvl);
            for(int ilambda = 0; ilambda < nlambda; ilambda ++){
                fprintf(fp, "%s  %s  %d  %e\n",
                        file_src_id_tr,
                        file_src_id_vl,
                        ilambda,
                        lambda_arr[ilambda]);
            }
        }
    }
    fclose(fp);
}


void LoadSrcIdDat(string src_id_dat,
                  long* const nsrc_id_true_ptr,
                  long** const src_id_true_arr_ptr,
                  long* const nsrc_id_false_ptr,
                  long** const src_id_false_arr_ptr)
{
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(src_id_dat, &lines_arr, &nline);
    long ntrue = 0;
    long nfalse = 0;
    for(long iline = 0; iline < nline; iline ++){
        int nsplit = 0;
        string* split_arr = NULL;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr);
        int true_false = atoi(split_arr[1].c_str());
        if(0 == true_false){
            nfalse ++;
        } else if (1 == true_false){
            ntrue ++;
        } else {
            abort();
        }
        MiStr::DelSplit(split_arr);
    }

    long* src_id_true_arr = new long [ntrue];
    long* src_id_false_arr = new long [nfalse];
    long itrue = 0;    
    long ifalse = 0;
    for(long iline = 0; iline < nline; iline ++){
        int nsplit = 0;
        string* split_arr = NULL;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr);
        int true_false = atoi(split_arr[1].c_str());
        if(0 == true_false){
            src_id_false_arr[ifalse] = atoi(split_arr[0].c_str());
            ifalse ++;
        } else if (1 == true_false){
            src_id_true_arr[itrue] = atoi(split_arr[0].c_str());
            itrue ++;
        } else {
            abort();
        }
        MiStr::DelSplit(split_arr);
    }
    delete [] lines_arr;

    *nsrc_id_true_ptr = ntrue;
    *nsrc_id_false_ptr = nfalse;
    *src_id_true_arr_ptr = src_id_true_arr;
    *src_id_false_arr_ptr = src_id_false_arr;
}

void GetData(long nhsc_data, const HscData* const* const hsc_data_arr,
             long nsrc_id, const long* const src_id_arr,
             long* const nfeature_ptr,
             double*** const feature_arr_ptr)
{
    long nfeature = nsrc_id;
    double** feature_arr = new double* [nsrc_id];
    for(long isrc = 0; isrc < nsrc_id; isrc ++){
        int nftr = hsc_data_arr[0]->GetNftr();
        feature_arr[isrc] = new double[nftr];
        for(int icol = 0; icol < nftr; icol ++){
            feature_arr[isrc][icol] =
                hsc_data_arr[src_id_arr[isrc] - 1]->GetFtrArrElm(icol);
        }
    }

    *nfeature_ptr = nfeature;
    *feature_arr_ptr = feature_arr;
}

void RunAucboostStep1(string csvfile,
                      string csv_version,
                      string src_id_dir,
                      int niter,
                      string outdir)
{
    printf(" --- RunAucboostStep1 --- \n");
    printf(" --- arg: RunAucboostStep1 ---- \n");
    printf(" csvfile = %s\n", csvfile.c_str());
    printf(" src_id_dir = %s\n", src_id_dir.c_str());
    printf(" niter = %d\n", niter);
    printf(" outdir = %s\n", outdir.c_str());
    printf(" --- arg: RunAucboostStep1 ---- \n");

    long nhsc_data = 0;
    HscData** hsc_data_arr = NULL;
    int nname = 0;
    string* name_arr = NULL;
    if("16051900" == csv_version){
        LoadCsvDat16051900(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    } else if("17112400" == csv_version){
        LoadCsvDat17112400(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    }
    printf("nhsc_data = %ld\n", nhsc_data);
    
    char trvl_lambda_dat[kLineSize];
    sprintf(trvl_lambda_dat, "%s/trvl_lambda.dat", outdir.c_str());
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(trvl_lambda_dat, &lines_arr, &nline);
    for(long iline = 0; iline < nline; iline ++){
        int nsplit = 0;
        string* split_arr = NULL;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr);

        char src_id_tr[kLineSize];
        sprintf(src_id_tr, "%s/%s",
                src_id_dir.c_str(), split_arr[0].c_str());
        char src_id_vl[kLineSize];
        sprintf(src_id_vl, "%s/%s",
                src_id_dir.c_str(), split_arr[1].c_str());
        int    ilambda = atoi(split_arr[2].c_str());
        double lambda  = atof(split_arr[3].c_str());

        long nsrc_id_true_tr = 0;
        long nsrc_id_false_tr = 0;
        long nsrc_id_true_vl = 0;
        long nsrc_id_false_vl = 0;
        long* src_id_true_tr_arr = NULL;
        long* src_id_false_tr_arr = NULL;        
        long* src_id_true_vl_arr = NULL;
        long* src_id_false_vl_arr = NULL;        
        
        LoadSrcIdDat(src_id_tr,
                     &nsrc_id_true_tr, &src_id_true_tr_arr,
                     &nsrc_id_false_tr, &src_id_false_tr_arr);
        LoadSrcIdDat(src_id_vl,
                     &nsrc_id_true_vl, &src_id_true_vl_arr,
                     &nsrc_id_false_vl, &src_id_false_vl_arr);

        long nfeature_true_tr = 0;
        double** feature_true_tr_arr = NULL;
        long nfeature_false_tr = 0;
        double** feature_false_tr_arr = NULL;
        long nfeature_true_vl = 0;
        double** feature_true_vl_arr = NULL;
        long nfeature_false_vl = 0;
        double** feature_false_vl_arr = NULL;

        GetData(nhsc_data, hsc_data_arr, nsrc_id_true_tr, src_id_true_tr_arr,
                &nfeature_true_tr, &feature_true_tr_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_false_tr, src_id_false_tr_arr,
                &nfeature_false_tr, &feature_false_tr_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_true_vl, src_id_true_vl_arr,
                &nfeature_true_vl, &feature_true_vl_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_false_vl, src_id_false_vl_arr,
                &nfeature_false_vl, &feature_false_vl_arr);

        char tag_lambda[kLineSize];
        sprintf(tag_lambda, "lambda_%2.2d_%.1e",
                ilambda, lambda);
        char outdir_tr[kLineSize];
        sprintf(outdir_tr, "%s/%s/%s",
                outdir.c_str(), split_arr[0].c_str(), tag_lambda);
        printf("outdir_tr = %s\n", outdir_tr);
        if( MiIolib::TestFileExist(outdir_tr) ){
            char cmd[kLineSize];
            sprintf(cmd, "mkdir -p %s", outdir_tr);
            system(cmd);
            printf("cmd = %s\n", cmd);
        }

        Aucboost(hsc_data_arr[0]->GetNftr(),
                 feature_true_tr_arr, nfeature_true_tr,
                 feature_false_tr_arr, nfeature_false_tr,
                 feature_true_vl_arr, nfeature_true_vl,
                 feature_false_vl_arr, nfeature_false_vl,
                 name_arr,
                 niter,
                 lambda,
                 outdir_tr);

        delete [] split_arr;
        delete [] src_id_true_tr_arr;
        delete [] src_id_false_tr_arr;
        delete [] src_id_true_vl_arr;
        delete [] src_id_false_vl_arr;
        for(long idata = 0; idata < nfeature_true_tr; idata ++){
            delete [] feature_true_tr_arr[idata];
        }
        delete [] feature_true_tr_arr;

        for(long idata = 0; idata < nfeature_false_tr; idata ++){
            delete [] feature_false_tr_arr[idata];
        }
        delete [] feature_false_tr_arr;

        for(long idata = 0; idata < nfeature_true_vl; idata ++){
            delete [] feature_true_vl_arr[idata];
        }
        delete [] feature_true_vl_arr;

        for(long idata = 0; idata < nfeature_false_vl; idata ++){
            delete [] feature_false_vl_arr[idata];
        }
        delete [] feature_false_vl_arr;
    }
    delete [] lines_arr;
    delete [] name_arr;
    for(long idata = 0; idata < nhsc_data; idata ++){
        delete hsc_data_arr[idata];
    }
    delete hsc_data_arr;
    printf(" === RunAucboostStep1 === \n");    
}

void GenBFzMArr(int nftr,
                const double* const* const data_true_tr_arr, long ndata_true_tr,
                const double* const* const data_false_tr_arr, long ndata_false_tr,
                double*** const B_arr_ptr,
                int** const nb_arr_ptr,
                double*** const Fz_arr_ptr,
                double**** const M0_arr_ptr,
                double**** const M1_arr_ptr)
{
    int n0_quantile = 10; // false
    int n1_quantile = 30; // true
    double* prob0_arr = new double [n0_quantile];
    double* prob1_arr = new double [n1_quantile];
    for(int iqtl = 0; iqtl < n0_quantile; iqtl ++){
        prob0_arr[iqtl] = (double) (iqtl + 1) / n0_quantile;
        printf("%f ", prob0_arr[iqtl]);
    }
    printf("\n");
    for(int iqtl = 0; iqtl < n1_quantile; iqtl ++){
        prob1_arr[iqtl] = (double) (iqtl + 1) / n1_quantile;
        printf("%f ", prob1_arr[iqtl]);
    }
    printf("\n");
    
    double** B0_arr = new double* [nftr];
    double** B1_arr = new double* [nftr];
    for(int iftr = 0; iftr < nftr; iftr++){
        double* data_true_tmp = new double[ndata_true_tr];
        for(long idata = 0; idata < ndata_true_tr; idata ++){
            data_true_tmp[idata] = data_true_tr_arr[idata][iftr];
        }
        double* data_false_tmp = new double[ndata_false_tr];
        for(long idata = 0; idata < ndata_false_tr; idata ++){
            data_false_tmp[idata] = data_false_tr_arr[idata][iftr];
        }

        B0_arr[iftr] = new double [n0_quantile];
        B1_arr[iftr] = new double [n1_quantile];
        for(int iqtl = 0; iqtl < n0_quantile; iqtl ++){
            B0_arr[iftr][iqtl] = 0.0;
        }
        for(int iqtl = 0; iqtl < n1_quantile; iqtl ++){
            B1_arr[iftr][iqtl] = 0.0;
        }
        TMath::Quantiles(ndata_false_tr, n0_quantile, data_false_tmp,
                         B0_arr[iftr], prob0_arr, kFALSE);
        TMath::Quantiles(ndata_true_tr, n1_quantile, data_true_tmp,
                         B1_arr[iftr], prob1_arr, kFALSE);
        //MirMathUtil::GetQuantile(ndata_false_tr, data_false_tmp,
        //                         n0_quantile,
        //                         &B0_arr[iftr]);
        //MirMathUtil::GetQuantile(ndata_true_tr, data_true_tmp,
        //                         n1_quantile,
        //                         &B1_arr[iftr]);
        delete [] data_true_tmp;
        delete [] data_false_tmp;
    }

    delete [] prob0_arr;
    delete [] prob1_arr;
    
    double** B_arr  = new double* [nftr];
    int* nb_arr    = new int [nftr];
    for(int iftr = 0; iftr < nftr; iftr++){
        int ntmp = n0_quantile + n1_quantile;
        double* tmp_arr = new double [ntmp];
        int itmp = 0;
        for(int iqtl = 0; iqtl < n0_quantile; iqtl ++){
            tmp_arr[itmp] = B0_arr[iftr][iqtl];
            itmp ++;
        }
        for(int iqtl = 0; iqtl < n1_quantile; iqtl ++){
            tmp_arr[itmp] = B1_arr[iftr][iqtl];
            itmp ++;
        }
        long nuniq = 0;
        double* uniq_arr = NULL;
        double epsilon = 1e-10;
        MirMathUtil::Uniq(ntmp, tmp_arr,
                          &nuniq, &uniq_arr,
                          epsilon);
        nb_arr[iftr] = nuniq;
        B_arr[iftr] = new double [nuniq];
        for(long iuniq = 0; iuniq < nuniq; iuniq ++){
            B_arr[iftr][iuniq] = uniq_arr[iuniq];
        }
        delete [] tmp_arr;
        delete [] uniq_arr;
    }
    for(int iftr = 0; iftr < nftr; iftr++){
        delete [] B0_arr[iftr];
        delete [] B1_arr[iftr];
    }
    delete [] B0_arr;
    delete [] B1_arr;

    // dump
    for(int iftr = 0; iftr < nftr; iftr++){
        printf("iftr = %d : nb = %d : ", iftr, nb_arr[iftr]);
        for(long iuniq = 0; iuniq < nb_arr[iftr]; iuniq ++){
            printf("%.3f ", B_arr[iftr][iuniq]);
        }
        printf("\n");
    }

    // Fz_arr
    double** Fz_arr  = new double* [nftr];
    for(int iftr = 0; iftr < nftr; iftr++){
        int nfz = nb_arr[iftr] + 3;
        Fz_arr[iftr] = new double [nfz];
        for(int ifz = 0; ifz < nfz; ifz ++){
            Fz_arr[iftr][ifz] = 0.0;
        }
    }

    long n0 = ndata_false_tr;
    long n1 = ndata_true_tr;
    
    // M0_arr
    double*** M0_arr = new double** [nftr];
    for(int iftr = 0; iftr < nftr; iftr++){
        M0_arr[iftr] = new double* [nb_arr[iftr]];
        for(int ib = 0; ib < nb_arr[iftr]; ib ++){
            M0_arr[iftr][ib] = new double [n0];
            for(long idata = 0; idata < n0; idata ++){
                if(data_false_tr_arr[idata][iftr] >= B_arr[iftr][ib]){
                    M0_arr[iftr][ib][idata] = 1.0;
                } else {
                    M0_arr[iftr][ib][idata] = 0.0;
                }
            }
        }
    }

    // M1_arr
    double*** M1_arr = new double** [nftr];
    for(int iftr = 0; iftr < nftr; iftr++){
        M1_arr[iftr] = new double* [nb_arr[iftr]];
        for(int ib = 0; ib < nb_arr[iftr]; ib ++){
            M1_arr[iftr][ib] = new double [n1];
            for(long idata = 0; idata < n1; idata ++){
                if(data_true_tr_arr[idata][iftr] >= B_arr[iftr][ib]){
                    M1_arr[iftr][ib][idata] = 1.0;
                } else {
                    M1_arr[iftr][ib][idata] = 0.0;
                }
            }
        }
    }


    *B_arr_ptr = B_arr;
    *nb_arr_ptr = nb_arr;
    *Fz_arr_ptr = Fz_arr;
    *M0_arr_ptr = M0_arr;
    *M1_arr_ptr = M1_arr;
}

void DelBFzMArr(int nftr,
                double** B_arr,
                int* nb_arr,
                double** Fz_arr,
                double*** M0_arr,
                double*** M1_arr)
{
    for(int iftr = 0; iftr < nftr; iftr++){
        delete [] B_arr[iftr];
    }
    delete [] B_arr;

    for(int iftr = 0; iftr < nftr; iftr++){
        delete [] Fz_arr[iftr];
    }
    delete Fz_arr;

    for(int iftr = 0; iftr < nftr; iftr++){
        for(int ib = 0; ib < nb_arr[iftr]; ib ++){
            delete [] M0_arr[iftr][ib];
        }
        delete [] M0_arr[iftr];
    }
    delete [] M0_arr;

    for(int iftr = 0; iftr < nftr; iftr++){
        for(int ib = 0; ib < nb_arr[iftr]; ib ++){
            delete [] M1_arr[iftr][ib];
        }
        delete [] M1_arr[iftr];
    }
    delete [] M1_arr;

    delete [] nb_arr;
}

    
double GetNot(double val)
{
    double ans = val * (-1) + 1;
    return(ans); 
}

double GetPhi(double val)
{
    double phi = exp( - val * val / 2.0) / sqrt(2.0 * M_PI);
    return(phi);
}

double GetScoreFuncVal(int npar,
                       const double* const a_arr,
                       const double* const b_arr,
                       const int* const p_arr,
                       const double* const alpha_arr,
                       int nftr, const double* const data_arr)
{
    double val = 0.0;
    for(int ipar = 0; ipar < npar; ipar++){
        double hev = 0.0;
        if(data_arr[ p_arr[ipar] ] - b_arr[ipar] >= 0){
            hev = 1.0;
        } else {
            hev = 0.0;
        }
        val += alpha_arr[ipar]
            * (a_arr[ipar] * hev + (1.0 - a_arr[ipar])/2.0);
    }
    return(val);
}


double GetAuc(long n0, const double* const F0_arr,
              long n1, const double* const F1_arr)
{
    double auc = 0.0;
    for(long iarr = 0; iarr < n0; iarr++){
        for(long jarr = 0; jarr < n1; jarr++){
            double hev = 0.0;
            if(F1_arr[jarr] - F0_arr[iarr] > 0){
                hev = 1.0;
            } else if(F1_arr[jarr] - F0_arr[iarr] == 0){
                hev = 0.5;
            } else {
                hev = 0.0;
            }
            auc += hev;
        }
    }
    auc /= (n0 * n1);
    return(auc);
}

void GenRoc(long n0, const double* const F0_arr,
            long n1, const double* const F1_arr,
            int npoint,
            double** const FPR_arr_ptr,
            double** const TPR_arr_ptr,
            double** const score_th_arr_ptr)
{
    long n01 = n0 + n1;
    double* F01_arr = new double [n01];
    long idata = 0;
    for(long iarr = 0; iarr < n0; iarr ++){
        F01_arr[idata] = F0_arr[iarr];
        idata ++;
    }
    for(long iarr = 0; iarr < n1; iarr ++){
        F01_arr[idata] = F1_arr[iarr];
        idata ++;
    }
    double F01_min = MirMath::GetMin(n01, F01_arr);
    double F01_max = MirMath::GetMax(n01, F01_arr);
    delete [] F01_arr;

    long nbin = npoint - 1;
    double delta = (F01_max - F01_min) / (nbin - 1);
    
    double* FPR_arr = new double [npoint];
    double* TPR_arr = new double [npoint];
    double* score_th_arr = new double [npoint];
    
    double F01_lo = F01_min - delta / 2.0;
    // double F01_up = F01_max + delta / 2.0;
    for(long ipoint = 0; ipoint < npoint; ipoint ++){
        double F01_th = F01_lo + delta * ipoint;
        FPR_arr[ipoint] = 0.0;
        for(long idata = 0; idata < n0; idata ++){
            if(F01_th <= F0_arr[idata]){
                FPR_arr[ipoint] ++;
            }
        }
        FPR_arr[ipoint] /= n0;

        TPR_arr[ipoint] = 0.0;
        for(long idata = 0; idata < n1; idata ++){
            if(F01_th <= F1_arr[idata]){
                TPR_arr[ipoint] ++;
            }
        }
        TPR_arr[ipoint] /= n1;
        score_th_arr[ipoint] = F01_th;
    }

    *FPR_arr_ptr = FPR_arr;
    *TPR_arr_ptr = TPR_arr;
    *score_th_arr_ptr = score_th_arr;
}

void GetMat01Arr(long n0, const double* const Mat0_arr,
                 long n1, const double* const Mat1_arr,
                 double* const Mat01_arr)
{
    for(long iarr = 0; iarr < n0; iarr++){
        for(long jarr = 0; jarr < n1; jarr++){
            long ij_index = iarr + jarr * n0;
            Mat01_arr[ij_index] = Mat1_arr[jarr] - Mat0_arr[iarr];
        }
    }
}


void MkBoostingParFile(int niter,
                       const double* const a_arr,
                       const double* const b_arr,
                       const int* const p_arr,
                       const double* const alpha_arr,
                       string outdir)
{
    char boosting_par_file[kLineSize];
    sprintf(boosting_par_file, "%s/boosting_par.dat", outdir.c_str());
    FILE* fp_boosting_par = fopen(boosting_par_file, "w");
    for(int ipar = 0; ipar < niter; ipar ++){
        fprintf(fp_boosting_par, "%+3.3f  %+3.3f  %2d  %+3.3f\n",
                a_arr[ipar], b_arr[ipar], p_arr[ipar], alpha_arr[ipar]);
    }
    fclose(fp_boosting_par);
}


void MkRocFile(long n0, const double* const F0_arr,
               long n1, const double* const F1_arr,
               int npoint, string outdir, string tag)
{
    double* FPR_arr = NULL;
    double* TPR_arr = NULL;
    double* score_th_arr = NULL;
    GenRoc(n0, F0_arr,
           n1, F1_arr,
           npoint,
           &FPR_arr, &TPR_arr, &score_th_arr);
        
    char roc_file[kLineSize];
    sprintf(roc_file, "%s/roc_%s.dat", outdir.c_str(), tag.c_str());
    FILE* fp_roc = fopen(roc_file, "w");
    for(long ipoint = 0; ipoint < npoint; ipoint ++){
        fprintf(fp_roc, "%e %e\n", FPR_arr[ipoint], TPR_arr[ipoint]);
    }
    fclose(fp_roc);
    delete [] FPR_arr;
    delete [] TPR_arr;
    delete [] score_th_arr;
}

void MkAucFile(int niter, const double* const auc_arr,
               string outdir, string tag)
{
    char auc_iter_file[kLineSize];
    sprintf(auc_iter_file, "%s/auc-iter_%s.dat", outdir.c_str(), tag.c_str());
    FILE* fp = fopen(auc_iter_file, "w");
    for(int ipar = 0; ipar < niter; ipar ++){
        fprintf(fp, "%e\n", auc_arr[ipar]);
    }
    fclose(fp);

    char auc_file[kLineSize];
    sprintf(auc_file, "%s/auc_%s.dat", outdir.c_str(), tag.c_str());
    fp = fopen(auc_file, "w");
    fprintf(fp, "%e\n", auc_arr[niter - 1]);
    fclose(fp);
}

// data_true_tr_arr[SRC][FTR]

// data_arr: ndata * nftr matrix
void Aucboost(int nftr,
              const double* const* const data_true_tr_arr, long ndata_true_tr,
              const double* const* const data_false_tr_arr, long ndata_false_tr,
              const double* const* const data_true_te_arr, long ndata_true_te,
              const double* const* const data_false_te_arr, long ndata_false_te,
              const string* const name_arr,
              int niter,
              double lambda,
              string outdir)
{
    printf(" --- aucboost ---- \n");
    printf("nftr   = %d\n", nftr);
    printf("ndata_true_tr = %ld\n", ndata_true_tr);
    printf("ndata_false_tr = %ld\n", ndata_false_tr);    
    printf("ndata_true_te = %ld\n", ndata_true_te);
    printf("ndata_false_te = %ld\n", ndata_false_te);    
    printf("niter   = %d\n", niter);
    printf("lambda  = %e\n", lambda);
    printf("outdir  = %s\n", outdir.c_str());
    printf(" --- aucboost ---- \n");

    long n0 = ndata_false_tr;
    long n1 = ndata_true_tr;
    long n0_te = ndata_false_te;
    long n1_te = ndata_true_te;

    // score value of each input data
    double* F0_arr = new double [n0];
    double* F1_arr = new double [n1];
    for(long idata = 0; idata < n0; idata ++){
        F0_arr[idata] = 0.0;
    }
    for(long idata = 0; idata < n1; idata ++){
        F1_arr[idata] = 0.0;
    }
    
    printf("--- GenBFzMArr\n");
    double** B_arr = NULL;
    int* nb_arr = NULL;
    double** Fz_arr = NULL;
    double*** M0_arr = NULL;
    double*** M1_arr = NULL;
    GenBFzMArr(nftr,
               data_true_tr_arr, ndata_true_tr,
               data_false_tr_arr, ndata_false_tr,
               &B_arr, &nb_arr, &Fz_arr,
               &M0_arr, &M1_arr);
    printf("=== GenBFzMArr\n");
    
    double* a_arr = new double [niter]; // +-1
    double* b_arr = new double [niter]; // threshold
    int*    p_arr = new int    [niter]; // index of feature
    double* alpha_arr = new double [niter]; // weight
    for(int iiter = 0; iiter < niter; iiter++){
        a_arr[iiter] = 0.0;
        b_arr[iiter] = 0.0;
        p_arr[iiter] = 0;
        alpha_arr[iiter] = 0.0;
    }
    double* auc_te_arr = new double [niter];
    double* auc_tr_arr = new double [niter];
    
    // boosting loop
    for(int iiter = 0; iiter < niter; iiter++){
        // printf("iiter (niter) = %d (%d)\n", iiter, niter);

        double* F01_arr = new double [n0 * n1];
        double* phi_arr = new double [n0 * n1];
        for(long iarr = 0; iarr < n0; iarr++){
            for(long jarr = 0; jarr < n1; jarr++){
                long ij_index = iarr + jarr * n0;
                F01_arr[ij_index] = F1_arr[jarr] - F0_arr[iarr];
                phi_arr[ij_index] = GetPhi(F01_arr[ij_index]);
            }
        }
        double** d_arr = new double* [nftr];
        for(int iftr = 0; iftr < nftr; iftr ++){
            d_arr[iftr] = new double[nb_arr[iftr]];
            for(int ib = 0; ib < nb_arr[iftr]; ib ++){
                
                double* M01_arr = new double [n0 * n1];
                for(long iarr = 0; iarr < n0; iarr++){
                    for(long jarr = 0; jarr < n1; jarr++){
                        long ij_index = iarr + jarr * n0;
                        M01_arr[ij_index] = M1_arr[iftr][ib][jarr] - M0_arr[iftr][ib][iarr];
                    }
                }
                d_arr[iftr][ib] = ddot_(n0 * n1, phi_arr, 1, M01_arr, 1);
                d_arr[iftr][ib] /= (n0 * n1);

                // regularization term
                double reg = Fz_arr[iftr][ib]
                    - 3 * Fz_arr[iftr][ib + 1]
                    + 3 * Fz_arr[iftr][ib + 2]
                    - Fz_arr[iftr][ib + 3];
                d_arr[iftr][ib] -= 2.0 * lambda * reg;

                delete [] M01_arr;
            }
        }

        double* dmin_arr = new double [nftr];
        double* dmax_arr = new double [nftr];
        int* index_dmin_arr = new int [nftr];
        int* index_dmax_arr = new int [nftr];
        for(int iftr = 0; iftr < nftr; iftr ++){
            dmin_arr[iftr] = MirMath::GetMin(nb_arr[iftr], d_arr[iftr]);
            dmax_arr[iftr] = MirMath::GetMax(nb_arr[iftr], d_arr[iftr]);
            index_dmin_arr[iftr] = MirMath::GetLocMin(nb_arr[iftr], d_arr[iftr]);
            index_dmax_arr[iftr] = MirMath::GetLocMax(nb_arr[iftr], d_arr[iftr]);
        }
        double dmin = MirMath::GetMin(nftr, dmin_arr);
        double dmax = MirMath::GetMax(nftr, dmax_arr);
        int index_dmin = MirMath::GetLocMin(nftr, dmin_arr);
        int index_dmax = MirMath::GetLocMax(nftr, dmax_arr);

        int ib_index = 0;
        if(dmax >= -dmin){
            a_arr[iiter] = 1;
            p_arr[iiter] = index_dmax;
            ib_index = index_dmax_arr[index_dmax];
        } else{
            a_arr[iiter] = -1;
            p_arr[iiter] = index_dmin;
            ib_index = index_dmin_arr[index_dmin];
        }

        b_arr[iiter] = B_arr[p_arr[iiter]][ib_index];

        // for alpha update
        double al = 0.0;
        if(iiter < 3){
            al = 1.0;
        } else {
            double* tmp_arr = new double [3];
            tmp_arr[0] = alpha_arr[iiter - 3];
            tmp_arr[1] = alpha_arr[iiter - 2];
            tmp_arr[2] = alpha_arr[iiter - 1];
            al = MirMath::GetMedian(3, tmp_arr);
            delete [] tmp_arr;
        }
        double al0 = 0.0;
        int inewton = 0;


        double* M01_arr = new double [n0 * n1];
        for(long iarr = 0; iarr < n0; iarr++){
            for(long jarr = 0; jarr < n1; jarr++){
                long ij_index = iarr + jarr * n0;
                M01_arr[ij_index] =
                    M1_arr[p_arr[iiter]][ib_index][jarr] -
                    M0_arr[p_arr[iiter]][ib_index][iarr];
            }
        }
        
        while( fabs( al - al0) > 1.0e-6 && inewton < 5){
            al0 = al;
            double d1 = 0.0;
            double d2 = 0.0;
            for(long iarr = 0; iarr < n0; iarr++){
                for(long jarr = 0; jarr < n1; jarr++){
                    long ij_index = iarr + jarr * n0;
                    double exponent = F01_arr[ij_index]
                        + al0 * a_arr[iiter] * M01_arr[ij_index];
                    double phi = GetPhi(exponent);
                    d1 += phi * a_arr[iiter] * M01_arr[ij_index];
                    d2 -= exponent * phi * pow(M01_arr[ij_index], 2);
                }
            }
            d1 /= n0 * n1;
            d2 /= n0 * n1;
            double dw1 = 2 * ( a_arr[iiter]
                        * ( Fz_arr[p_arr[iiter]][ib_index] - 3 * Fz_arr[p_arr[iiter]][ib_index + 1]
                            + 3 * Fz_arr[p_arr[iiter]][ib_index + 2] - Fz_arr[p_arr[iiter]][ib_index + 3] )
                        + 2 * al0);
            double dw2 = 4.0;
            al = al0 - (d1 - lambda * dw1) / (d2 - lambda * dw2);
            inewton ++;
        }
        delete [] M01_arr;
        
        alpha_arr[iiter] = al;
        
        if(1 == a_arr[iiter]){
            for(long iarr = 0; iarr < n0; iarr++){
                F0_arr[iarr] += al * M0_arr[p_arr[iiter]][ib_index][iarr];
            }
            for(long jarr = 0; jarr < n1; jarr++){
                F1_arr[jarr] += al * M1_arr[p_arr[iiter]][ib_index][jarr];
            }
            int nfz = nb_arr[p_arr[iiter]] + 3;
            for(int ifz = ib_index + 2; ifz < nfz; ifz ++){
                Fz_arr[p_arr[iiter]][ifz] += al;
            }
        } else{
            for(long iarr = 0; iarr < n0; iarr++){
                F0_arr[iarr] += al * GetNot(M0_arr[p_arr[iiter]][ib_index][iarr]);
            }
            for(long jarr = 0; jarr < n1; jarr++){
                F1_arr[jarr] += al * GetNot(M1_arr[p_arr[iiter]][ib_index][jarr]);
            }
            for(int ifz = 0; ifz <= ib_index + 1; ifz ++){
                Fz_arr[p_arr[iiter]][ifz] += al;
            }
        }


        int npoint = 1000;
        double* F0_te_arr = new double [n0_te];
        double* F1_te_arr = new double [n1_te];
        for(long idata = 0; idata < n0_te; idata ++){
            F0_te_arr[idata] = GetScoreFuncVal(iiter + 1,
                                               a_arr, b_arr, p_arr, alpha_arr,
                                               nftr, data_false_te_arr[idata]);
        }
        for(long idata = 0; idata < n1_te; idata ++){
            F1_te_arr[idata] = GetScoreFuncVal(iiter + 1,
                                               a_arr, b_arr, p_arr, alpha_arr,
                                               nftr, data_true_te_arr[idata]);
        }
        auc_te_arr[iiter] = GetAuc(n0_te, F0_te_arr,
                                   n1_te, F1_te_arr);
        auc_tr_arr[iiter] = GetAuc(n0, F0_arr,
                                   n1, F1_arr);
        MkRocFile(n0_te, F0_te_arr, n1_te, F1_te_arr, npoint, outdir, "te");
        MkRocFile(n0, F0_arr, n1, F1_arr, npoint, outdir, "tr");
        
        printf("%s: iiter = %2.2d: auc_tr = %f: auc_te = %f: "
               "a, b, p, alpha = %+3.3f  %+3.3f  %2d  %+3.3f \n",
               outdir.c_str(), iiter, auc_tr_arr[iiter], auc_te_arr[iiter],
               a_arr[iiter], b_arr[iiter], p_arr[iiter], alpha_arr[iiter]);


        delete [] F01_arr;
        delete [] phi_arr;
        for(int iftr = 0; iftr < nftr; iftr ++){
            delete [] d_arr[iftr];
        }
        delete [] d_arr;

        delete [] dmin_arr;
        delete [] dmax_arr;
        delete [] index_dmin_arr;
        delete [] index_dmax_arr;

        delete [] F0_te_arr;
        delete [] F1_te_arr;
    }

    int npoint = 1000;
    double* F0_te_arr = new double [n0_te];
    double* F1_te_arr = new double [n1_te];
    for(long idata = 0; idata < n0_te; idata ++){
        F0_te_arr[idata] = GetScoreFuncVal(niter,
                                           a_arr, b_arr, p_arr, alpha_arr,
                                           nftr, data_false_te_arr[idata]);
    }
    for(long idata = 0; idata < n1_te; idata ++){
        F1_te_arr[idata] = GetScoreFuncVal(niter,
                                           a_arr, b_arr, p_arr, alpha_arr,
                                           nftr, data_true_te_arr[idata]);
    }
    MkRocFile(n0_te, F0_te_arr, n1_te, F1_te_arr, npoint, outdir, "te");
    delete [] F0_te_arr;
    delete [] F1_te_arr;
    
    MkBoostingParFile(niter, a_arr, b_arr, p_arr, alpha_arr, outdir);
    MkRocFile(n0, F0_arr, n1, F1_arr, npoint, outdir, "tr");
    
    
    MkAucFile(niter, auc_te_arr, outdir, "te");
    MkAucFile(niter, auc_tr_arr, outdir, "tr");
    

    delete [] F0_arr;
    delete [] F1_arr;
    
    DelBFzMArr(nftr, B_arr, nb_arr, Fz_arr,
               M0_arr, M1_arr);
    delete [] a_arr;
    delete [] b_arr;
    delete [] p_arr;
    delete [] alpha_arr;

    delete [] auc_te_arr;
    delete [] auc_tr_arr;

    printf("=== aucboost ===\n");
}


// for step2

void LoadLambdaArr(string lambda_file,
                   int* const nlambda_ptr,
                   double** const lambda_arr_ptr)
{

    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(lambda_file,
                                    &lines_arr, &nline);
    int nlambda = nline;
    double* lambda_arr = new double [nlambda];
    for(long iline = 0; iline < nline; iline ++){
        int nsplit = 0;
        string* split_arr = NULL;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr);
        lambda_arr[iline] = atof(split_arr[1].c_str());
        MiStr::DelSplit(split_arr);
    }
    delete [] lines_arr;
    *nlambda_ptr    = nlambda;
    *lambda_arr_ptr = lambda_arr;
}

void MkTrVlTeLambdaDat(int nset,
                       const double* const lambda_arr,
                       string outdir)
{
    int nfile_src_id_te = nset;
    char trvlte_lambda_dat[kLineSize];
    sprintf(trvlte_lambda_dat, "%s/trvlte_lambda.dat", outdir.c_str());
    FILE* fp = fopen(trvlte_lambda_dat, "w");
    for(int index_te = 1; index_te <= nfile_src_id_te; index_te ++){
        char file_src_id_tr[kLineSize];
        char file_src_id_vl[kLineSize];
        char file_src_id_te[kLineSize];
        sprintf(file_src_id_tr, "cv%2.2d-01-tr.csv", index_te);
        sprintf(file_src_id_vl, "cv%2.2d-01-vl.csv", index_te);
        sprintf(file_src_id_te, "cv%2.2d-te.csv", index_te);

        fprintf(fp, "%s  %s  %s  %e\n",
                file_src_id_tr,
                file_src_id_vl,
                file_src_id_te,
                lambda_arr[index_te - 1]);
    }
    fclose(fp);
}


void RunAucboostStep2(string csvfile,
                      string csv_version,
                      string src_id_dir,
                      int niter,
                      string outdir)
{
    printf(" --- RunAucboostStep2 --- \n");
    printf(" --- arg: RunAucboostStep2 ---- \n");
    printf(" csvfile = %s\n", csvfile.c_str());
    printf(" src_id_dir = %s\n", src_id_dir.c_str());
    printf(" niter = %d\n", niter);
    printf(" outdir = %s\n", outdir.c_str());
    printf(" --- arg: RunAucboostStep2 ---- \n");

    long nhsc_data = 0;
    HscData** hsc_data_arr = NULL;
    int nname = 0;
    string* name_arr = NULL;
    if("16051900" == csv_version){
        LoadCsvDat16051900(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    } else if("17112400" == csv_version){
        LoadCsvDat17112400(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    }
    printf("nhsc_data = %ld\n", nhsc_data);
    
    char trvl_lambda_dat[kLineSize];
    sprintf(trvl_lambda_dat, "%s/trvlte_lambda.dat", outdir.c_str());
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(trvl_lambda_dat, &lines_arr, &nline);
    for(long iline = 0; iline < nline; iline ++){
        int nsplit = 0;
        string* split_arr = NULL;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr);

        char src_id_tr[kLineSize];
        sprintf(src_id_tr, "%s/%s",
                src_id_dir.c_str(), split_arr[0].c_str());
        char src_id_vl[kLineSize];
        sprintf(src_id_vl, "%s/%s",
                src_id_dir.c_str(), split_arr[1].c_str());
        char src_id_te[kLineSize];
        sprintf(src_id_te, "%s/%s",
                src_id_dir.c_str(), split_arr[2].c_str());
        double lambda  = atof(split_arr[3].c_str());

        long nsrc_id_true_tr = 0;
        long nsrc_id_false_tr = 0;
        long nsrc_id_true_vl = 0;
        long nsrc_id_false_vl = 0;
        long nsrc_id_true_te = 0;
        long nsrc_id_false_te = 0;
        long* src_id_true_tr_arr = NULL;
        long* src_id_false_tr_arr = NULL;        
        long* src_id_true_vl_arr = NULL;
        long* src_id_false_vl_arr = NULL;
        long* src_id_true_te_arr = NULL;
        long* src_id_false_te_arr = NULL;        
        LoadSrcIdDat(src_id_tr,
                     &nsrc_id_true_tr, &src_id_true_tr_arr,
                     &nsrc_id_false_tr, &src_id_false_tr_arr);
        LoadSrcIdDat(src_id_vl,
                     &nsrc_id_true_vl, &src_id_true_vl_arr,
                     &nsrc_id_false_vl, &src_id_false_vl_arr);
        LoadSrcIdDat(src_id_te,
                     &nsrc_id_true_te, &src_id_true_te_arr,
                     &nsrc_id_false_te, &src_id_false_te_arr);


        long nsrc_id_true_trvl = nsrc_id_true_tr + nsrc_id_true_vl;
        long* src_id_true_trvl_arr = new long [nsrc_id_true_trvl];
        long isrc_tot = 0;
        for(long isrc = 0; isrc < nsrc_id_true_tr; isrc ++){
            src_id_true_trvl_arr[isrc_tot] = src_id_true_tr_arr[isrc];
            isrc_tot ++;
        }
        for(long isrc = 0; isrc < nsrc_id_true_vl; isrc ++){
            src_id_true_trvl_arr[isrc_tot] = src_id_true_vl_arr[isrc];
            isrc_tot ++;
        }

        long nsrc_id_false_trvl = nsrc_id_false_tr + nsrc_id_false_vl;
        long* src_id_false_trvl_arr = new long [nsrc_id_false_trvl];
        isrc_tot = 0;
        for(long isrc = 0; isrc < nsrc_id_false_tr; isrc ++){
            src_id_false_trvl_arr[isrc_tot] = src_id_false_tr_arr[isrc];
            isrc_tot ++;
        }
        for(long isrc = 0; isrc < nsrc_id_false_vl; isrc ++){
            src_id_false_trvl_arr[isrc_tot] = src_id_false_vl_arr[isrc];
            isrc_tot ++;
        }
        
        long nfeature_true_trvl = 0;
        double** feature_true_trvl_arr = NULL;
        long nfeature_false_trvl = 0;
        double** feature_false_trvl_arr = NULL;

        long nfeature_true_te = 0;
        double** feature_true_te_arr = NULL;
        long nfeature_false_te = 0;
        double** feature_false_te_arr = NULL;

        GetData(nhsc_data, hsc_data_arr, nsrc_id_true_trvl, src_id_true_trvl_arr,
                &nfeature_true_trvl, &feature_true_trvl_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_false_trvl, src_id_false_trvl_arr,
                &nfeature_false_trvl, &feature_false_trvl_arr);

        GetData(nhsc_data, hsc_data_arr, nsrc_id_true_te, src_id_true_te_arr,
                &nfeature_true_te, &feature_true_te_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_false_te, src_id_false_te_arr,
                &nfeature_false_te, &feature_false_te_arr);

        char outdir_te[kLineSize];
        sprintf(outdir_te, "%s/%s",
                outdir.c_str(), split_arr[2].c_str());
        printf("outdir_te = %s\n", outdir_te);
        if( MiIolib::TestFileExist(outdir_te) ){
            char cmd[kLineSize];
            sprintf(cmd, "mkdir -p %s", outdir_te);
            system(cmd);
            printf("cmd = %s\n", cmd);
        }

        Aucboost(hsc_data_arr[0]->GetNftr(),
                 feature_true_trvl_arr, nfeature_true_trvl,
                 feature_false_trvl_arr, nfeature_false_trvl,
                 feature_true_te_arr, nfeature_true_te,
                 feature_false_te_arr, nfeature_false_te,
                 name_arr,
                 niter,
                 lambda,
                 outdir_te);

        delete [] split_arr;
        delete [] src_id_true_tr_arr;
        delete [] src_id_false_tr_arr;
        delete [] src_id_true_vl_arr;
        delete [] src_id_false_vl_arr;
        delete [] src_id_true_te_arr;
        delete [] src_id_false_te_arr;
        delete [] src_id_true_trvl_arr;
        delete [] src_id_false_trvl_arr;
        
        for(long idata = 0; idata < nfeature_true_trvl; idata ++){
            delete [] feature_true_trvl_arr[idata];
        }
        delete [] feature_true_trvl_arr;

        for(long idata = 0; idata < nfeature_false_trvl; idata ++){
            delete [] feature_false_trvl_arr[idata];
        }
        delete [] feature_false_trvl_arr;

        for(long idata = 0; idata < nfeature_true_te; idata ++){
            delete [] feature_true_te_arr[idata];
        }
        delete [] feature_true_te_arr;

        for(long idata = 0; idata < nfeature_false_te; idata ++){
            delete [] feature_false_te_arr[idata];
        }
        delete [] feature_false_te_arr;
    }
    delete [] lines_arr;
    delete [] name_arr;
    for(long idata = 0; idata < nhsc_data; idata ++){
        delete hsc_data_arr[idata];
    }
    delete hsc_data_arr;
    printf(" === RunAucboostStep2 === \n");
}


void MkRocAve(int nset, string outdir)
{
    Gd2dFunc** func_roc_arr = new Gd2dFunc*[nset];
    for(int iset = 0; iset < nset; iset ++){
        char roc_file[kLineSize];
        sprintf(roc_file, "%s/cv%2.2d-te.csv/roc_te.dat",
                outdir.c_str(), iset + 1);
        long ndata = 0;
        string* data_line_arr = NULL;
        MiIolib::GenReadFileSkipComment(roc_file,
                                        &data_line_arr, &ndata);
        printf("iset: %d: ndata = %ld\n", iset, ndata);
        double* fpr_arr = new double [ndata];
        double* tpr_arr = new double [ndata];
        for(long idata = 0; idata < ndata; idata ++){
            int nsplit = 0;
            string* split_arr = NULL;
            MiStr::GenSplit(data_line_arr[idata],
                            &nsplit, &split_arr, " ");
            fpr_arr[idata] = atof(split_arr[0].c_str());
            tpr_arr[idata] = atof(split_arr[1].c_str());
            delete [] split_arr;
        }
        delete [] data_line_arr;

        GraphDataNerr2d* gd2d_roc = new GraphDataNerr2d;
        gd2d_roc->Init(ndata);
        gd2d_roc->SetXvalArr(ndata, fpr_arr);
        gd2d_roc->SetOvalArr(ndata, tpr_arr);
        gd2d_roc->Sort();

        func_roc_arr[iset] = new Gd2dFunc;
        func_roc_arr[iset]->InitSetGd2d(gd2d_roc);

        char qdpout[kLineSize];
        sprintf(qdpout, "%s/roc_%2.2d.qdp", outdir.c_str(), iset + 1);
        MirQdpTool::MkQdp(gd2d_roc, qdpout, "x,y");

        delete [] fpr_arr;
        delete [] tpr_arr;
        delete gd2d_roc;
    }

    // make averaged roc file
    char outroc[kLineSize];
    sprintf(outroc, "%s/roc_ave.dat", outdir.c_str());
    FILE* fp_roc = fopen(outroc, "w");
    int nfpr = 300;
    double fpr_lo = 0.0;
    double fpr_up = 1.0;
    double delta_fpr = (fpr_up - fpr_lo) / nfpr;
    for(int ifpr = 0; ifpr < nfpr; ifpr ++){
        double fpr = fpr_lo + (ifpr + 0.5) * delta_fpr;
        double ave = 0.0;
        for(int iset = 0; iset < nset; iset ++){
            double fpr_arr[1];
            fpr_arr[0] = fpr;
            ave += func_roc_arr[iset]->Eval(fpr_arr, NULL);
        }
        ave /= nset;
        fprintf(fp_roc, "%e  %e\n", fpr, ave);
    }
    fclose(fp_roc);

}

// step3


void MkTrVlTeLambdaDat(int nset,
                       int nlambda,
                       const double* const lambda_arr,
                       string outdir)
{
    int nfile_src_id_te = nset;
    char trvlte_lambda_dat[kLineSize];
    sprintf(trvlte_lambda_dat, "%s/trvlte_lambda.dat", outdir.c_str());
    FILE* fp = fopen(trvlte_lambda_dat, "w");
    for(int index_te = 1; index_te <= nfile_src_id_te; index_te ++){
        char file_src_id_tr[kLineSize];
        char file_src_id_vl[kLineSize];
        char file_src_id_te[kLineSize];
        sprintf(file_src_id_tr, "cv%2.2d-01-tr.csv", index_te);
        sprintf(file_src_id_vl, "cv%2.2d-01-vl.csv", index_te);
        sprintf(file_src_id_te, "cv%2.2d-te.csv", index_te);

        for(int ilambda = 0; ilambda < nlambda; ilambda ++){
            fprintf(fp, "%s  %s  %s  %d  %e\n",
                    file_src_id_tr,
                    file_src_id_vl,
                    file_src_id_te,
                    ilambda,
                    lambda_arr[ilambda]);
        }
    }
    fclose(fp);
}


void RunAucboostStep3(string csvfile,
                      string csv_version,
                      string src_id_dir,
                      int niter,
                      string outdir)
{
    printf(" --- RunAucboostStep3 --- \n");
    printf(" --- arg: RunAucboostStep3 ---- \n");
    printf(" csvfile = %s\n", csvfile.c_str());
    printf(" src_id_dir = %s\n", src_id_dir.c_str());
    printf(" niter = %d\n", niter);
    printf(" outdir = %s\n", outdir.c_str());
    printf(" --- arg: RunAucboostStep3 ---- \n");

    long nhsc_data = 0;
    HscData** hsc_data_arr = NULL;
    int nname = 0;
    string* name_arr = NULL;
    if("16051900" == csv_version){
        LoadCsvDat16051900(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    } else if("17112400" == csv_version){
        LoadCsvDat17112400(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    }
    printf("nhsc_data = %ld\n", nhsc_data);
    
    char trvl_lambda_dat[kLineSize];
    sprintf(trvl_lambda_dat, "%s/trvlte_lambda.dat", outdir.c_str());
    string* lines_arr = NULL;
    long nline = 0;
    MiIolib::GenReadFileSkipComment(trvl_lambda_dat, &lines_arr, &nline);
    for(long iline = 0; iline < nline; iline ++){
        int nsplit = 0;
        string* split_arr = NULL;
        MiStr::GenSplit(lines_arr[iline], &nsplit, &split_arr);

        char src_id_tr[kLineSize];
        sprintf(src_id_tr, "%s/%s",
                src_id_dir.c_str(), split_arr[0].c_str());
        char src_id_vl[kLineSize];
        sprintf(src_id_vl, "%s/%s",
                src_id_dir.c_str(), split_arr[1].c_str());
        char src_id_te[kLineSize];
        sprintf(src_id_te, "%s/%s",
                src_id_dir.c_str(), split_arr[2].c_str());
        int    ilambda = atoi(split_arr[3].c_str());
        double lambda  = atof(split_arr[4].c_str());

        long nsrc_id_true_tr = 0;
        long nsrc_id_false_tr = 0;
        long nsrc_id_true_vl = 0;
        long nsrc_id_false_vl = 0;
        long nsrc_id_true_te = 0;
        long nsrc_id_false_te = 0;
        long* src_id_true_tr_arr = NULL;
        long* src_id_false_tr_arr = NULL;        
        long* src_id_true_vl_arr = NULL;
        long* src_id_false_vl_arr = NULL;
        long* src_id_true_te_arr = NULL;
        long* src_id_false_te_arr = NULL;        
        LoadSrcIdDat(src_id_tr,
                     &nsrc_id_true_tr, &src_id_true_tr_arr,
                     &nsrc_id_false_tr, &src_id_false_tr_arr);
        LoadSrcIdDat(src_id_vl,
                     &nsrc_id_true_vl, &src_id_true_vl_arr,
                     &nsrc_id_false_vl, &src_id_false_vl_arr);
        LoadSrcIdDat(src_id_te,
                     &nsrc_id_true_te, &src_id_true_te_arr,
                     &nsrc_id_false_te, &src_id_false_te_arr);


        long nsrc_id_true_trvl = nsrc_id_true_tr + nsrc_id_true_vl;
        long* src_id_true_trvl_arr = new long [nsrc_id_true_trvl];
        long isrc_tot = 0;
        for(long isrc = 0; isrc < nsrc_id_true_tr; isrc ++){
            src_id_true_trvl_arr[isrc_tot] = src_id_true_tr_arr[isrc];
            isrc_tot ++;
        }
        for(long isrc = 0; isrc < nsrc_id_true_vl; isrc ++){
            src_id_true_trvl_arr[isrc_tot] = src_id_true_vl_arr[isrc];
            isrc_tot ++;
        }

        long nsrc_id_false_trvl = nsrc_id_false_tr + nsrc_id_false_vl;
        long* src_id_false_trvl_arr = new long [nsrc_id_false_trvl];
        isrc_tot = 0;
        for(long isrc = 0; isrc < nsrc_id_false_tr; isrc ++){
            src_id_false_trvl_arr[isrc_tot] = src_id_false_tr_arr[isrc];
            isrc_tot ++;
        }
        for(long isrc = 0; isrc < nsrc_id_false_vl; isrc ++){
            src_id_false_trvl_arr[isrc_tot] = src_id_false_vl_arr[isrc];
            isrc_tot ++;
        }
        
        long nfeature_true_trvl = 0;
        double** feature_true_trvl_arr = NULL;
        long nfeature_false_trvl = 0;
        double** feature_false_trvl_arr = NULL;

        long nfeature_true_te = 0;
        double** feature_true_te_arr = NULL;
        long nfeature_false_te = 0;
        double** feature_false_te_arr = NULL;

        GetData(nhsc_data, hsc_data_arr, nsrc_id_true_trvl, src_id_true_trvl_arr,
                &nfeature_true_trvl, &feature_true_trvl_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_false_trvl, src_id_false_trvl_arr,
                &nfeature_false_trvl, &feature_false_trvl_arr);

        GetData(nhsc_data, hsc_data_arr, nsrc_id_true_te, src_id_true_te_arr,
                &nfeature_true_te, &feature_true_te_arr);
        GetData(nhsc_data, hsc_data_arr, nsrc_id_false_te, src_id_false_te_arr,
                &nfeature_false_te, &feature_false_te_arr);

        char tag_lambda[kLineSize];
        sprintf(tag_lambda, "lambda_%2.2d_%.1e",
                ilambda, lambda);
        char outdir_te[kLineSize];
        sprintf(outdir_te, "%s/%s/%s",
                outdir.c_str(), split_arr[2].c_str(), tag_lambda);
        printf("outdir_te = %s\n", outdir_te);
        if( MiIolib::TestFileExist(outdir_te) ){
            char cmd[kLineSize];
            sprintf(cmd, "mkdir -p %s", outdir_te);
            system(cmd);
            printf("cmd = %s\n", cmd);
        }

        Aucboost(hsc_data_arr[0]->GetNftr(),
                 feature_true_trvl_arr, nfeature_true_trvl,
                 feature_false_trvl_arr, nfeature_false_trvl,
                 feature_true_te_arr, nfeature_true_te,
                 feature_false_te_arr, nfeature_false_te,
                 name_arr,
                 niter,
                 lambda,
                 outdir_te);

        delete [] split_arr;
        delete [] src_id_true_tr_arr;
        delete [] src_id_false_tr_arr;
        delete [] src_id_true_vl_arr;
        delete [] src_id_false_vl_arr;
        delete [] src_id_true_te_arr;
        delete [] src_id_false_te_arr;
        delete [] src_id_true_trvl_arr;
        delete [] src_id_false_trvl_arr;
        
        for(long idata = 0; idata < nfeature_true_trvl; idata ++){
            delete [] feature_true_trvl_arr[idata];
        }
        delete [] feature_true_trvl_arr;

        for(long idata = 0; idata < nfeature_false_trvl; idata ++){
            delete [] feature_false_trvl_arr[idata];
        }
        delete [] feature_false_trvl_arr;

        for(long idata = 0; idata < nfeature_true_te; idata ++){
            delete [] feature_true_te_arr[idata];
        }
        delete [] feature_true_te_arr;

        for(long idata = 0; idata < nfeature_false_te; idata ++){
            delete [] feature_false_te_arr[idata];
        }
        delete [] feature_false_te_arr;
    }
    delete [] lines_arr;
    delete [] name_arr;
    for(long idata = 0; idata < nhsc_data; idata ++){
        delete hsc_data_arr[idata];
    }
    delete hsc_data_arr;
    printf(" === RunAucboostStep3 === \n");
}


// step4

void GetDataNoSel(long nhsc_data, const HscData* const* const hsc_data_arr,
                  long* const nfeature_true_ptr,
                  double*** const feature_true_arr_ptr,
                  long* const nfeature_false_ptr,
                  double*** const feature_false_arr_ptr)
{
    long nfeature_true = 0;
    long nfeature_false = 0;
    for(long isrc = 0; isrc < nhsc_data; isrc ++){
        if(0 == hsc_data_arr[isrc]->GetTrueFalse()){
            nfeature_false ++;
        } else if(1 == hsc_data_arr[isrc]->GetTrueFalse()){
            nfeature_true ++;
        } else {
            abort();
        }
    }

    double** feature_true_arr = new double* [nfeature_true];        
    double** feature_false_arr = new double* [nfeature_false];
    int nftr = hsc_data_arr[0]->GetNftr();
    long ifeature_true = 0;
    long ifeature_false = 0;    
    for(long isrc = 0; isrc < nhsc_data; isrc ++){
        if(0 == hsc_data_arr[isrc]->GetTrueFalse()){
            feature_false_arr[ifeature_false] = new double[nftr];
            for(int icol = 0; icol < nftr; icol ++){
                feature_false_arr[ifeature_false][icol] =
                    hsc_data_arr[isrc]->GetFtrArrElm(icol);
            }
            ifeature_false ++;
        } else if(1 == hsc_data_arr[isrc]->GetTrueFalse()){
            feature_true_arr[ifeature_true] = new double[nftr];
            for(int icol = 0; icol < nftr; icol ++){
                feature_true_arr[ifeature_true][icol] =
                    hsc_data_arr[isrc]->GetFtrArrElm(icol);
            }
            ifeature_true ++;
        } else {
            abort();
        }
    }

    *nfeature_true_ptr = nfeature_true;
    *feature_true_arr_ptr = feature_true_arr;
    *nfeature_false_ptr = nfeature_false;
    *feature_false_arr_ptr = feature_false_arr;
    
}

void RunAucboostStep4(string csvfile,
                      string csv_version,
                      int niter,
                      double lambda,
                      string outdir)
{
    printf(" --- RunAucboostStep4 --- \n");
    printf(" --- arg: RunAucboostStep4 ---- \n");
    printf(" csvfile = %s\n", csvfile.c_str());
    printf(" niter = %d\n", niter);
    printf(" lambda = %e\n", lambda);
    printf(" outdir = %s\n", outdir.c_str());
    printf(" --- arg: RunAucboostStep4 ---- \n");

    long nhsc_data = 0;
    HscData** hsc_data_arr = NULL;
    int nname = 0;
    string* name_arr = NULL;
    if("16051900" == csv_version){
        LoadCsvDat16051900(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    } else if("17112400" == csv_version){
        LoadCsvDat17112400(csvfile, &nhsc_data, &hsc_data_arr,
                           &nname, &name_arr);
    }
    printf("nhsc_data = %ld\n", nhsc_data);
    

    long nfeature_true = 0;
    double** feature_true_arr = NULL;
    long nfeature_false = 0;
    double** feature_false_arr = NULL;
    GetDataNoSel(nhsc_data, hsc_data_arr, 
                 &nfeature_true, &feature_true_arr,
                 &nfeature_false, &feature_false_arr);

    printf("nfeature_true = %ld\n", nfeature_true);
    printf("nfeature_false = %ld\n", nfeature_false);

    Aucboost(hsc_data_arr[0]->GetNftr(),
             feature_true_arr, nfeature_true,
             feature_false_arr, nfeature_false,
             feature_true_arr, nfeature_true,
             feature_false_arr, nfeature_false,
             name_arr,
             niter,
             lambda,
             outdir);

    for(long idata = 0; idata < nfeature_true; idata ++){
        delete [] feature_true_arr[idata];
    }
    delete [] feature_true_arr;

    for(long idata = 0; idata < nfeature_false; idata ++){
        delete [] feature_false_arr[idata];
    }
    delete [] feature_false_arr;

    delete [] name_arr;
    for(long idata = 0; idata < nhsc_data; idata ++){
        delete hsc_data_arr[idata];
    }
    delete hsc_data_arr;
    printf(" === RunAucboostStep4 === \n");
}






